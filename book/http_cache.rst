.. index::
   single: Cache

HTTP Cache
HTTP缓存
==========

The nature of rich web applications means that they're dynamic. No matter
how efficient your application, each request will always contain more overhead
than serving a static file.
丰富的web应用意味着它们是动态的。不管你的应用多么有效率，对于一个动态应用来说，每个
请求都会比静态页面花费更多开销。

And for most Web applications, that's fine. Symfony2 is lightning fast, and
unless you're doing some serious heavy-lifting, each request will come back
quickly without putting too much stress on your server.
对于大多数的web应用，这都没问题，symfony2很快，除非你刻意做大量工作，否则所有的请求都会
很快返回，而不给服务器太大压力。

But as your site grows, that overhead can become a problem. The processing
that's normally performed on every request should be done only once. This
is exactly what caching aims to accomplish.
但当你的站点开始成长，那个开销可能会变成一个难题。每个请求的过程都只要被执行一次，这就是缓存的目标。

Caching on the Shoulders of Giants
站在巨人的肩膀上
----------------------------------

The most effective way to improve performance of an application is to cache
the full output of a page and then bypass the application entirely on each
subsequent request. Of course, this isn't always possible for highly dynamic
websites, or is it? In this chapter, we'll show you how the Symfony2 cache
system works and why we think this is the best possible approach.
最有效的提高应用性能的方法就是将整个页面缓存，接下来的请求内部的各个执行过程就可以被跳过。当然，
对于一个动态页面来说，这几乎不可能。在本章中，我们将展示给你symfony缓存的工作机制，以及它的优点。

The Symfony2 cache system is different because it relies on the simplicity
and power of the HTTP cache as defined in the :term:`HTTP specification`.
Instead of reinventing a caching methodology, Symfony2 embraces the standard
that defines basic communication on the Web. Once you understand the fundamental
HTTP validation and expiration caching models, you'll be ready to master
the Symfony2 cache system.
symfony2缓存系统的工作是不同的，因为它立足于HTTP缓存的简单强大（见:term:`HTTP specification`）。
symfony2使用web基本通信标准，而不是自己重建缓存算法。一旦你掌握了基本的HTTP验证和expiration缓存模型，你
就差不多掌握了symfony缓存系统的方法。

For the purposes of learning how to cache with Symfony2, we'll cover the
subject in four steps:
为了学习symfony缓存，我们将分四步掌握：

* **Step 1**: A :ref:`gateway cache <gateway-caches>`, or reverse proxy, is
  an independent layer that sits in front of your application. The reverse
  proxy caches responses as they're returned from your application and answers
  requests with cached responses before they hit your application. Symfony2
  provides its own reverse proxy, but any reverse proxy can be used.
  **第一步**：:ref:`gateway cache <gateway-caches>`，或者reverse proxy，是一个你的应用
  前端的独立层。reverse proxy会缓存从你的应用返回的响应（response），并使用这个缓存响应请求。
  symfony2提供它自己的reverse proxy，但是任何reverse proxy都可以使用。

* **Step 2**: :ref:`HTTP cache <http-cache-introduction>` headers are used
  to communicate with the gateway cache and any other caches between your
  application and the client. Symfony2 provides sensible defaults and a
  powerful interface for interacting with the cache headers.
  **第二步**： :ref:`HTTP cache <http-cache-introduction>`头文件（header）被用来在gateway cache
  和任何在你的应用和客户端之间的其他缓存通信。symfony2提供默认的和强大的接口，用于和缓存头文件交互。

* **Step 3**: HTTP :ref:`expiration and validation <http-expiration-validation>`
  are the two models used for determining whether cached content is *fresh*
  (can be reused from the cache) or *stale* (should be regenerated by the
  application).
  **第三步**： HTTP :ref:`expiration and validation <http-expiration-validation>`是两个用来确定
  缓存内容是否过期的模型。如果内容是新鲜（fresh）的，那么它可以被继续使用；如果是陈旧（stale）的，就
  要从应用中重新集成。

* **Step 4**: :ref:`Edge Side Includes <edge-side-includes>` (ESI) allow HTTP
  cache to be used to cache page fragments (even nested fragments) independently.
  With ESI, you can even cache an entire page for 60 minutes, but an embedded
  sidebar for only 5 minutes.
  **第四步**： :ref:`Edge Side Includes <edge-side-includes>` (ESI)允许HTTP缓存被
  用来独立地缓存页面片段（即使是嵌入的片段）。使用ESI，你可以将整个页面缓存60分钟，但只将一个嵌入的
  侧边栏缓存5分钟。

Since caching with HTTP isn't unique to Symfony, many articles already exist
on the topic. If you're new to HTTP caching, we *highly* recommend Ryan
Tomayko's article `Things Caches Do`_. Another in-depth resource is Mark
Nottingham's `Cache Tutorial`_.
HTTP缓存并不是什么新兴事物，很多文章已经有详细介绍。如果你刚接触缓存，我们强烈建议你阅读`Things Caches Do`_
和`Cache Tutorial`_。

.. index::
   single: Cache; Proxy
   single: Cache; Reverse Proxy
   single: Cache; Gateway

.. _gateway-caches:

Caching with a Gateway Cache
使用gateway缓存
----------------------------

When caching with HTTP, the *cache* is separated from your application entirely
and sits between your application and the client making the request.
当使用HTTP缓存时，缓存被从你的应用中剥离，并置于你的应用和客户端之间。

The job of the cache is to accept requests from the client and pass them
back to your application. The cache will also receive responses back from
your application and forward them on to the client. The cache is the "middle-man"
of the request-response communication between the client and your application.
缓存的作用接受请求并且将它们发送到你的应用。缓存同样也会从你的应用接受响应并且将它们
转发给客户端。缓存是应用和客户端之间进行请求-响应通信的中间人。

Along the way, the cache will store each response that is deemed "cacheable"
(See :ref:`http-cache-introduction`). If the same resource is requested again,
the cache sends the cached response to the client, ignoring your application
entirely.
缓存会存储可以被缓存的响应。如果相同的资源被重复请求，缓存会忽略你的应用并直接将
缓存的回应发送给客户端。

This type of cache is known as a HTTP gateway cache and many exist such
as `Varnish`_, `Squid in reverse proxy mode`_, and the Symfony2 reverse proxy.
这种类型的缓存被称作HTTP gateway缓存，有许多这样的缓存，比如`Varnish`_, 
`Squid in reverse proxy mode`_, 以及Symfony2 reverse proxy。

.. index::
   single: Cache; Types of

Types of Caches
缓存类型
~~~~~~~~~~~~~~~

But a gateway cache isn't the only type of cache. In fact, the HTTP cache
headers sent by your application are consumed and interpreted by up to three
different types of caches:
但是gateway缓存并非缓存的唯一类型。事实上，你的应用发送的HTTP缓存头文件被三个
不同类型的缓存使用并解析了：

* *Browser caches*: Every browser comes with its own local cache that is
  mainly useful for when you hit "back" or for images and other assets.
  The browser cache is a *private* cache as cached resources aren't shared
  with anyone else.
  *浏览器缓存*： 每个浏览器都有它自己的本地缓存，这个缓存主要用于用户点击后退按钮的时候，或请求图像和其他
  资源时用到。浏览器缓存是一个私有的缓存，因为缓存资源不和其他用户分享。

* *Proxy caches*: A proxy is a *shared* cache as many people can be behind a
  single one. It's usually installed by large corporations and ISPs to reduce
  latency and network traffic.
  *代理缓存*： 一个代理就是一个一个分享式缓存，因为许多用户可以使用同一个缓存。
  它通常被运用于大的公司和ISP，从而降低带宽消耗和服务器负荷。

* *Gateway caches*: Like a proxy, it's also a *shared* cache but on the server
  side. Installed by network administrators, it makes websites more scalable,
  reliable and performant.
  *gateway缓存*：像代理一样，它也是一个分享式缓存，但是是在服务器端的。网站管理员通过安装它
  来使网站更轻量级、更稳定、性能更好。

.. tip::

    Gateway caches are sometimes referred to as reverse proxy caches,
    surrogate caches, or even HTTP accelerators.
    gateway缓存有时候也被称为reverse proxy缓存，surrogate caches, 或HTTP accelerators。

.. note::

    The significance of *private* versus *shared* caches will become more
    obvious as we talk about caching responses containing content that is
    specific to exactly one user (e.g. account information).
    随着我们讨论包含针对某一个用户的缓存响应（比如账户信息）的深入，私有和分享式缓存
    的区别会越来越明显。

Each response from your application will likely go through one or both of
the first two cache types. These caches are outside of your control but follow
the HTTP cache directions set in the response.
你的应用的响应大致上会通过以上三种缓存类型的前两种或一种。这些缓存脱离于你的控制之外，但是
它们遵循响应中设置的HTTP缓存规则。

.. index::
   single: Cache; Symfony2 Reverse Proxy

.. _`symfony-gateway-cache`:

Symfony2 Reverse Proxy
~~~~~~~~~~~~~~~~~~~~~~

Symfony2 comes with a reverse proxy (also called a gateway cache) written
in PHP. Enable it and cacheable responses from your application will start
to be cached right away. Installing it is just as easy. Each new Symfony2
application comes with a pre-configured caching kernel (``AppCache``) that
wraps the default one (``AppKernel``). The caching Kernel *is* the reverse
proxy.
symfony自带一个用php写的reverse proxy（也被称作gateway缓存）。激活它，然后可以被缓存
的响应就会开始被缓存了。安装它很容易，每个新的symfony2应用都有一个事先定义好的缓存核心
(``AppCache``)，它包装了默认的那个核心(``AppKernel``)。这个缓存核心就是reverse proxy。

To enable caching, modify the code of a front controller to use the caching
kernel::
要激活缓存，修改前端控制器的代码，从而使用缓存核心::

    // web/app.php

    require_once __DIR__.'/../app/bootstrap.php.cache';
    require_once __DIR__.'/../app/AppKernel.php';
    require_once __DIR__.'/../app/AppCache.php';

    use Symfony\Component\HttpFoundation\Request;

    $kernel = new AppKernel('prod', false);
    $kernel->loadClassCache();
    // wrap the default AppKernel with the AppCache one
    $kernel = new AppCache($kernel);
    $kernel->handle(Request::createFromGlobals())->send();

The caching kernel will immediately act as a reverse proxy - caching responses
from your application and returning them to the client.
这个缓存核心会作为一个reverse proxy来工作——从你的应用中缓存响应并将它们返回给客户端。

.. tip::

    The cache kernel has a special ``getLog()`` method that returns a string
    representation of what happened in the cache layer. In the development
    environment, use it to debug and validate your cache strategy::
    缓存核心有一个特别的``getLog()``，它可以将缓存层中发生的事件作为字符串返回。
    在开发环境中，使用它来调试并验证你的缓存机制::

        error_log($kernel->getLog());

The ``AppCache`` object has a sensible default configuration, but it can be
finely tuned via a set of options you can set by overriding the ``getOptions()``
method::
``AppCache``对象有一个明了的默认配置，但是你也可以通过覆盖``getOptions()``方法来
自定义::

    // app/AppCache.php

    use Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache;

    class AppCache extends HttpCache
    {
        protected function getOptions()
        {
            return array(
                'debug'                  => false,
                'default_ttl'            => 0,
                'private_headers'        => array('Authorization', 'Cookie'),
                'allow_reload'           => false,
                'allow_revalidate'       => false,
                'stale_while_revalidate' => 2,
                'stale_if_error'         => 60,
            );
        }
    }

.. tip::

    Unless overridden in ``getOptions()``, the ``debug`` option will be set
    to automatically be the debug value of the wrapped ``AppKernel``.
    除非你覆盖``getOptions()``，否则这个debug选项会自动被设置为被包围的``AppKernel``中的值。

Here is a list of the main options:
以下是一些主要选项：

* ``default_ttl``: The number of seconds that a cache entry should be
  considered fresh when no explicit freshness information is provided in a
  response. Explicit ``Cache-Control`` or ``Expires`` headers override this
  value (default: ``0``);
* ``default_ttl``: 规定当响应中没有显性地定义freshness信息时，一个缓存入口在多少
  秒内应该被视为fresh的。显性的``Cache-Control``或``Expires``头文件会覆盖这个值（默认：0）；

* ``private_headers``: Set of request headers that trigger "private"
  ``Cache-Control`` behavior on responses that don't explicitly state whether
  the response is ``public`` or ``private`` via a ``Cache-Control`` directive.
  (default: ``Authorization`` and ``Cookie``);
* ``private_headers``:一系列的请求头文件（header），这些文件可以在没有显性地通过``Cache-Control``规则表明该响应是public
  的还是private的响应上触发"private" ``Cache-Control``行为。(默认：``Authorization`` and ``Cookie``)

* ``allow_reload``: Specifies whether the client can force a cache reload by
  including a ``Cache-Control`` "no-cache" directive in the request. Set it to
  ``true`` for compliance with RFC 2616 (default: ``false``);
* ``allow_reload``: 确定客户端是否可以通过在请求中包含``Cache-Control`` "no-cache"规则强制缓存重载。
  和RFC 2616兼容，设置其为true；

* ``allow_revalidate``: Specifies whether the client can force a cache
  revalidate by including a ``Cache-Control`` "max-age=0" directive in the
  request. Set it to ``true`` for compliance with RFC 2616 (default: false);
* ``allow_revalidate``: 确定客户端能否通过在请求中包含``Cache-Control`` "max-age=0"
  规则来强制缓存重验证。和RFC 2616兼容，设置其为true(默认: false)；

* ``stale_while_revalidate``: Specifies the default number of seconds (the
  granularity is the second as the Response TTL precision is a second) during
  which the cache can immediately return a stale response while it revalidates
  it in the background (default: ``2``); this setting is overridden by the
  ``stale-while-revalidate`` HTTP ``Cache-Control`` extension (see RFC 5861);
* ``stale_while_revalidate``: 指定当缓存在后台重新验证的时候，多少秒内（由于响应TTL精度是秒，
  这里的粒度也是秒）缓存可以返回一个旧的响应（默认：2）。这个设置可以被HTTP ``Cache-Control``
  扩展中的``stale-while-revalidate``覆盖（见RFC5861）；

* ``stale_if_error``: Specifies the default number of seconds (the granularity
  is the second) during which the cache can serve a stale response when an
  error is encountered (default: ``60``). This setting is overridden by the
  ``stale-if-error`` HTTP ``Cache-Control`` extension (see RFC 5861).
* ``stale_if_error``: 指定当错误发生时，在多少秒内（粒度是秒）可以返回一个旧的响应（默认：60）。
  这个设置可以被HTTP ``Cache-Control``扩展的``stale-if-error``覆盖。

If ``debug`` is ``true``, Symfony2 automatically adds a ``X-Symfony-Cache``
header to the response containing useful information about cache hits and
misses.
如果debug是true，symfony2自动向包含关于缓存信息的响应添加一个``X-Symfony-Cache``头文件。

.. sidebar:: Changing from one Reverse Proxy to Another

    The Symfony2 reverse proxy is a great tool to use when developing your
    website or when you deploy your website to a shared host where you cannot
    install anything beyond PHP code. But being written in PHP, it cannot
    be as fast as a proxy written in C. That's why we highly recommend you
    to use Varnish or Squid on your production servers if possible. The good
    news is that the switch from one proxy server to another is easy and
    transparent as no code modification is needed in your application. Start
    easy with the Symfony2 reverse proxy and upgrade later to Varnish when
    your traffic increases.
    当开发你自己的网站或者当你将网站置于只能安装php代码的共享主机时，
    symfony2 reverse proxy是一个非常强大的工具。但是它是用php写的，不能像用c写的代理
    一样快。这就是为什么我们极力推荐你在你的服务器上使用Varnish或者squid的原因。
    从一个代理转到另一个代理很容易，不需要在应用中修改代码。首先使用比较容易的symfony2 reverse
    proxy，当网站流量起来后再升级到Varnish。

    For more information on using Varnish with Symfony2, see the
    :doc:`How to use Varnish </cookbook/cache/varnish>` cookbook chapter.
    要了解更多关于如何使用Varnish的知识请参阅:doc:`How to use Varnish </cookbook/cache/varnish>`。
    
.. note::

    The performance of the Symfony2 reverse proxy is independent of the
    complexity of the application. That's because the application kernel is
    only booted when the request needs to be forwarded to it.
    symfony2 reverse proxy的性能是独立于应用的复杂度之外的。这是因为这个应用核心只在
    请求需要被转发到它的时候才被启用。

.. index::
   single: Cache; HTTP

.. _http-cache-introduction:

Introduction to HTTP Caching
介绍HTTP缓存
----------------------------

To take advantage of the available cache layers, your application must be
able to communicate which responses are cacheable and the rules that govern
when/how that cache should become stale. This is done by setting HTTP cache
headers on the response.
要利用已有的缓存层，你的应用必须能够与能够被缓存的响应以及确定了缓存何时过时（stale）的规则通信。
这是通过在响应中设置HTTP缓存头文件（header）实现的。

.. tip::

    Keep in mind that "HTTP" is nothing more than the language (a simple text
    language) that web clients (e.g. browsers) and web servers use to communicate
    with each other. When we talk about HTTP caching, we're talking about the
    part of that language that allows clients and servers to exchange information
    related to caching.
    请记住HTTP只是一门web客户端和服务器进行通信的语言（简单的文本语言）。当我们讨论
    HTTP缓存的时候，我们实际是在讨论这门允许客户端和服务器关于缓存进行交互的语言。

HTTP specifies four response cache headers that we're concerned with:
HTTP确定了四个响应缓存头文件：

* ``Cache-Control``
* ``Expires``
* ``ETag``
* ``Last-Modified``

The most important and versatile header is the ``Cache-Control`` header,
which is actually a collection of various cache information.
最重要也最多用到的是Cache-control头文件，它是一个多个缓存信息的集合。

.. note::

    Each of the headers will be explained in full detail in the
    :ref:`http-expiration-validation` section.
    每个头文件都在:ref:`http-expiration-validation`章节中有详细的介绍。
    
.. index::
   single: Cache; Cache-Control Header
   single: HTTP headers; Cache-Control

The Cache-Control Header
Cache-Controle头文件
~~~~~~~~~~~~~~~~~~~~~~~~

The ``Cache-Control`` header is unique in that it contains not one, but various
pieces of information about the cacheability of a response. Each piece of
information is separated by a comma:
Cache-Control头文件是独特的，因为它包含了不止一个，而是多个关于响应缓存信息的
信息。每个信息被逗号隔开：

     Cache-Control: private, max-age=0, must-revalidate

     Cache-Control: max-age=3600, must-revalidate

Symfony provides an abstraction around the ``Cache-Control`` header to make
its creation more manageable:
symfony提供了打包Cache-Control头文件的方法，使它更易于操作：

.. code-block:: php

    $response = new Response();

    // mark the response as either public or private
    $response->setPublic();
    $response->setPrivate();

    // set the private or shared max age
    $response->setMaxAge(600);
    $response->setSharedMaxAge(600);

    // set a custom Cache-Control directive
    $response->headers->addCacheControlDirective('must-revalidate', true);

Public vs Private Responses
公共的和私有的响应
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Both gateway and proxy caches are considered "shared" caches as the cached
content is shared by more than one user. If a user-specific response were
ever mistakenly stored by a shared cache, it might be returned later to any
number of different users. Imagine if your account information were cached
and then returned to every subsequent user who asked for their account page!
gateway和代理缓存都是分享缓存，因为被缓存的内容能够被多个用户分享。如果一个用户用户特定的
响应（如用户账户信息）被错误地存储在分享缓存中，它就会被返回给多个其他用户。

To handle this situation, every response may be set to be public or private:
要解决这个问题，每个响应都必须被设置为public或者private：

* *public*: Indicates that the response may be cached by both private and
  shared caches;
  *public*： 表示这个响应可以被私有或分享缓存来缓存；

* *private*: Indicates that all or part of the response message is intended
  for a single user and must not be cached by a shared cache.
* *private*：表示这个响应信息的所有部分都只返回给一个用户且不可以被分享缓存缓存。
  
Symfony conservatively defaults each response to be private. To take advantage
of shared caches (like the Symfony2 reverse proxy), the response will need
to be explicitly set as public.
symfony保守地将每个响应都默认设置为私有（private）的。要利用分享缓存（像symfony2
reverse proxy），响应要被显性地设置为共有的（public）。

.. index::
   single: Cache; Safe methods

Safe Methods
安全方法
~~~~~~~~~~~~

HTTP caching only works for "safe" HTTP methods (like GET and HEAD). Being
safe means that you never change the application's state on the server when
serving the request (you can of course log information, cache data, etc).
This has two very reasonable consequences:
HTTP缓存只用于安全的HTTP方法（像get或head）。使用安全方法表示你在处理请求时，永远不改变你的
服务器上应用的状态（当然你可以log信息，缓存数据，等等）。
那么就有以下两点：

* You should *never* change the state of your application when responding
  to a GET or HEAD request. Even if you don't use a gateway cache, the presence
  of proxy caches mean that any GET or HEAD request may or may not actually
  hit your server.
  当响应一个get或head请求时，你永远也不能改变你应用的状态。即使你不使用一个gateway缓存，proxy
  缓存的存在也使get或head请求可能或者不可能达到你的服务器。

* Don't expect PUT, POST or DELETE methods to cache. These methods are meant
  to be used when mutating the state of your application (e.g. deleting a
  blog post). Caching them would prevent certain requests from hitting and
  mutating your application.
  不要指望PUT,POST,DELETE方法能够缓存。这些方法本来就是使你的应用的状态变化的方法（比如删除一个博客）。
  缓存它们可能导致某些请求不能到达或改变你的应用。

Caching Rules and Defaults
缓存规则和默认情况
~~~~~~~~~~~~~~~~~~~~~~~~~~

HTTP 1.1 allows caching anything by default unless there is an explicit
``Cache-Control`` header. In practice, most caches do nothing when requests
have a cookie, an authorization header, use a non-safe method (i.e. PUT, POST,
DELETE), or when responses have a redirect status code.
HTTP 1.1允许缓存任何东西除非有个显性的Cache-Control头文件。实际上，当请求有cookie，或一个
认证头文件，或使用一个不安全的方法（比如PUT,POST,DELETE），或响应有一个重定向，大多数缓存
都不做任何事情。

Symfony2 automatically sets a sensible and conservative ``Cache-Control``
header when none is set by the developer by following these rules:
当开发者不设置Cache-Control的时候，symfony2自动根据以下规则设置一个保守的Cache-Control头文件：

* If no cache header is defined (``Cache-Control``, ``Expires``, ``ETag``
  or ``Last-Modified``), ``Cache-Control`` is set to ``no-cache``, meaning
  that the response will not be cached;
  如果没有缓存头文件被定义（``Cache-Control``, ``Expires``, ``ETag``
  或 ``Last-Modified``），``Cache-Control``被设置为``no-cache``，表示这个响应
  不会被缓存；

* If ``Cache-Control`` is empty (but one of the other cache headers is present),
  its value is set to ``private, must-revalidate``;
  如果``Cache-Control``是空的（但是有其他的缓存头文件），它的值会被设置为``private, must-revalidate``；
  
* But if at least one ``Cache-Control`` directive is set, and no 'public' or
  ``private`` directives have been explicitly added, Symfony2 adds the
  ``private`` directive automatically (except when ``s-maxage`` is set).
  但是如果至少有一个``Cache-Control``规则被设置，并且没有‘public’或‘private’规则被添加，symfony2
  会自动添加private规则（除非s-maxage被设置）。

.. _http-expiration-validation:

HTTP Expiration and Validation
HTTP过期和验证
------------------------------

The HTTP specification defines two caching models:
HTTP规则定义了两种缓存模型：

* With the `expiration model`_, you simply specify how long a response should
  be considered "fresh" by including a ``Cache-Control`` and/or an ``Expires``
  header. Caches that understand expiration will not make the same request
  until the cached version reaches its expiration time and becomes "stale".
* 在`expiration model`_中，你只是通过包含Cache-Control头文件和/或Expires头文件指定
  在多长时间内一个响应应该被认为是fresh的。在缓存达到它的过期时间并变成stale
  之前，它不会发送同样的请求。
  
* When pages are really dynamic (i.e. their representation changes often),
  the `validation model`_ is often necessary. With this model, the
  cache stores the response, but asks the server on each request whether
  or not the cached response is still valid. The application uses a unique
  response identifier (the ``Etag`` header) and/or a timestamp (the ``Last-Modified``
  header) to check if the page has changed since being cached.
* 当页面为动态时（或者说它们经常变化），`validation model`_会经常被用到。在这个模式中，
  缓存会存储响应，但是会在收到每个请求是都会像服务器确认被缓存的响应是否还有效。应用
  会使用一个唯一的响应标识符（Etag头文件）和/或一个timestamp（Last-Modified头文件）来
  检查页面是否在缓存后发生了变化。
  
The goal of both models is to never generate the same response twice by relying
on a cache to store and return "fresh" responses.
这两个模式的目标都是依据缓存来存取数据并保证不将同一个响应集成两遍。

.. sidebar:: Reading the HTTP Specification

    The HTTP specification defines a simple but powerful language in which
    clients and servers can communicate. As a web developer, the request-response
    model of the specification dominates our work. Unfortunately, the actual
    specification document - `RFC 2616`_ - can be difficult to read.
    HTTP标准定义了一个简单但是强大的客户端和服务器通信的语言。这个标准的请求-响应
    模式主导了我们工作。不幸的是，实际的标准文档——`RFC 2616`——很难读。
    
    There is an on-going effort (`HTTP Bis`_) to rewrite the RFC 2616. It does
    not describe a new version of HTTP, but mostly clarifies the original HTTP
    specification. The organization is also improved as the specification
    is split into seven parts; everything related to HTTP caching can be
    found in two dedicated parts (`P4 - Conditional Requests`_ and `P6 -
    Caching: Browser and intermediary caches`_).
    有一个目的在于重写`RFC 2616`的项目正在进行中（`HTTP Bis`_）。它并不是重新定义HTTP
    标准，而是更清晰地表达该标准的定义。这些标准被分割成7个部分；所有与HTTP缓存有关的
    部分都可以在两个特定的章节中找到(`P4 - Conditional Requests`_ and `P6 -
    Caching: Browser and intermediary caches`_)。
    
    As a web developer, we strongly urge you to read the specification. Its
    clarity and power - even more than ten years after its creation - is
    invaluable. Don't be put-off by the appearance of the spec - its contents
    are much more beautiful than its cover.
    我们强烈要求你阅读这个标准。它是无价之宝。不要被它的样子吓到，它的内容很精彩。
    
.. index::
   single: Cache; HTTP Expiration

Expiration
过期
~~~~~~~~~~

The expiration model is the more efficient and straightforward of the two
caching models and should be used whenever possible. When a response is cached
with an expiration, the cache will store the response and return it directly
without hitting the application until it expires.
过期（expiration）模式是两者中最有效和最直接的，只要可以，尽量用过期模式。当一个
响应被用过期模式缓存时，它会被直接返回给客户端而不到达应用层。

The expiration model can be accomplished using one of two, nearly identical,
HTTP headers: ``Expires`` or ``Cache-Control``.
过期模式可以通过两个HTTP头文件运用，这两个HTTP头文件都差不多：``Expires``或``Cache-Control``。

.. index::
   single: Cache; Expires header
   single: HTTP headers; Expires

Expiration with the ``Expires`` Header
使用Expires头文件
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

According to the HTTP specification, "the ``Expires`` header field gives
the date/time after which the response is considered stale." The ``Expires``
header can be set with the ``setExpires()`` ``Response`` method. It takes a
``DateTime`` instance as an argument::
根据HTTP标准，Expires头文件在响应过期后会给出date/time。Expires头文件可以使用``setExpires()`` ``Response``
方法来设置。它使用一个DateTime对象作为参数::

    $date = new DateTime();
    $date->modify('+600 seconds');

    $response->setExpires($date);

The resulting HTTP header will look like this::
作为结果的HTTP头文件会看起来像这样::

    Expires: Thu, 01 Mar 2011 16:00:00 GMT

.. note::

    The ``setExpires()`` method automatically converts the date to the GMT
    timezone as required by the specification.
    在被请求时，setExpires()方法会自动将date转换成GMT时区。

Note that in HTTP versions before 1.1 the origin server wasn't required to
send the ``Date`` header. Consequently the cache (e.g. the browser) might
need to rely onto his local clock to evaluate the ``Expires`` header making
the lifetime calculation vulnerable to clock skew. Another limitation
of the ``Expires`` header is that the specification states that "HTTP/1.1
servers should not send ``Expires`` dates more than one year in the future."
注意在1.1之前的HTTP版本中，源服务器不能被请求发送Date头文件。所以缓存（或者说浏览器）
可能需要依赖它的本地时钟来计算expires头文件中的时间，这样的话过期的时间计算会变得
混乱。expires头文件还有一个缺陷就是HTTP标准中规定发送的过期时间不得超过一年。

.. index::
   single: Cache; Cache-Control header
   single: HTTP headers; Cache-Control

Expiration with the ``Cache-Control`` Header
使用Cache-Control头文件设置缓存过期
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Because of the ``Expires`` header limitations, most of the time, you should
use the ``Cache-Control`` header instead. Recall that the ``Cache-Control``
header is used to specify many different cache directives. For expiration,
there are two directives, ``max-age`` and ``s-maxage``. The first one is
used by all caches, whereas the second one is only taken into account by
shared caches::
由于expires头文件的限制，大部分情况下，你必须使用Cache-Control头文件来确定许多不同的缓存设置。
要设置过期，有两种设置，max-age和s-maxage。第一个在所有缓存中都可以使用，但第二个只在分享缓存
（shared caches）中才有效::

    // Sets the number of seconds after which the response
    // should no longer be considered fresh
    $response->setMaxAge(600);

    // Same as above but only for shared caches
    $response->setSharedMaxAge(600);

The ``Cache-Control`` header would take on the following format (it may have
additional directives)::
Cache-Control头文件会使用以下格式（它可能还会有别的配置）::

    Cache-Control: max-age=600, s-maxage=600

.. index::
   single: Cache; Validation

Validation
验证
~~~~~~~~~~

When a resource needs to be updated as soon as a change is made to the underlying
data, the expiration model falls short. With the expiration model, the application
won't be asked to return the updated response until the cache finally becomes
stale.
当缓存中的数据的源被改变时，缓存中的数据也需要被改变。这时过期模式就显示出缺陷了，因为
除非缓存过期，否则它是不会让请求到达应用层的，也就是说不会返回更新的数据。

The validation model addresses this issue. Under this model, the cache continues
to store responses. The difference is that, for each request, the cache asks
the application whether or not the cached response is still valid. If the
cache *is* still valid, your application should return a 304 status code
and no content. This tells the cache that it's ok to return the cached response.
验证模式纠正了这个缺陷。在这个模式下，缓存会继续存储响应数据，但是不同的是，对于每个请求，缓存
都会询问应用层被缓存的响应是否还有效。如果缓存依旧有效，你的应用会返回一个304 status code，不返回
内容。这告诉缓存可以返回被缓存的响应。

Under this model, you mainly save bandwidth as the representation is not
sent twice to the same client (a 304 response is sent instead). But if you
design your application carefully, you might be able to get the bare minimum
data needed to send a 304 response and save CPU also (see below for an implementation
example).
在这个模式下，你主要是节省了带宽，因为页面不会被两次发送给客户端（而是发送304响应）。但是如果
你谨慎地设计你的应用，你就可以用尽可能少的数据来生成304响应，从而节省CPU（见以下例子）。

.. tip::

    The 304 status code means "Not Modified". It's important because with
    this status code do *not* contain the actual content being requested.
    Instead, the response is simply a light-weight set of directions that
    tell cache that it should use its stored version.
    304 status code表示“没有修改（Not Modified）”。它不包含页面内容，相反，这个
    响应只是一个轻量级的设置集合，告诉缓存应该使用它存储的数据。

Like with expiration, there are two different HTTP headers that can be used
to implement the validation model: ``ETag`` and ``Last-Modified``.
像expiration一样，验证模式有两个不同的HTTP头文件：Etag和Last-Modified。

.. index::
   single: Cache; Etag header
   single: HTTP headers; Etag

Validation with the ``ETag`` Header
使用ETag进行验证
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``ETag`` header is a string header (called the "entity-tag") that uniquely
identifies one representation of the target resource. It's entirely generated
and set by your application so that you can tell, for example, if the ``/about``
resource that's stored by the cache is up-to-date with what your application
would return. An ``ETag`` is like a fingerprint and is used to quickly compare
if two different versions of a resource are equivalent. Like fingerprints,
each ``ETag`` must be unique across all representations of the same resource.
ETag头文件是一个字符串头文件（名叫entity-tag）,它可以唯一确定目标源数据的表现样式。它
完全由你的应用集成，并且你可以，比如，确定被缓存的/about源数据是否是你的应用可能返回的
最新数据版本。ETag可以用来迅速判断两个源数据的版本是否一致。在同一源数据的所有表现样式
中，ETag必须唯一。

Let's walk through a simple implementation that generates the ETag as the
md5 of the content::
举个简单例子，在这个例子中集成了ETag，这个ETag是响应内容的md5编码::

    public function indexAction()
    {
        $response = $this->render('MyBundle:Main:index.html.twig');
        $response->setETag(md5($response->getContent()));
        $response->isNotModified($this->getRequest());

        return $response;
    }

The ``Response::isNotModified()`` method compares the ``ETag`` sent with
the ``Request`` with the one set on the ``Response``. If the two match, the
method automatically sets the ``Response`` status code to 304.
``Response::isNotModified()``方法将request对象发送的ETag和response对象上设置的ETag
作对比。如果两者匹配，这个方法将自动把响应status code设置为304。

This algorithm is simple enough and very generic, but you need to create the
whole ``Response`` before being able to compute the ETag, which is sub-optimal.
In other words, it saves on bandwidth, but not CPU cycles.
这个算法很简单并通用，但是你必须在计算ETag之前创建整个response，这又不是很合算。
换句话说，它节省了带宽，但是却加重了cpu负荷。

In the :ref:`optimizing-cache-validation` section, we'll show how validation
can be used more intelligently to determine the validity of a cache without
doing so much work.
在:ref:`optimizing-cache-validation`章节中，我们将展示如何更高效地利用验证。

.. tip::

    Symfony2 also supports weak ETags by passing ``true`` as the second
    argument to the
    :method:`Symfony\\Component\\HttpFoundation\\Response::setETag` method.
    通过将true作为第二个参数传递给:method:`Symfony\\Component\\HttpFoundation\\Response::setETag`方法，symfony2也支持弱ETag。

.. index::
   single: Cache; Last-Modified header
   single: HTTP headers; Last-Modified

Validation with the ``Last-Modified`` Header
通过``Last-Modified``头文件验证
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``Last-Modified`` header is the second form of validation. According
to the HTTP specification, "The ``Last-Modified`` header field indicates
the date and time at which the origin server believes the representation
was last modified." In other words, the application decides whether or not
the cached content has been updated based on whether or not it's been updated
since the response was cached.
``Last-Modified``头文件是验证的第二种形式。根据HTTP标准，``Last-Modified``头文件
字段表明源服务器认为页面最后被修改的时间和日期。换句话说，由你的应用根据响应在被缓存之后
是否被更新过这个事实来决定缓存的内容是否被更新。

For instance, you can use the latest update date for all the objects needed to
compute the resource representation as the value for the ``Last-Modified``
header value::
比如，你可以使用所有对象的最新更新日期作为``Last-Modified``头文件的值来计算：

    public function showAction($articleSlug)
    {
        // ...

        $articleDate = new \DateTime($article->getUpdatedAt());
        $authorDate = new \DateTime($author->getUpdatedAt());

        $date = $authorDate > $articleDate ? $authorDate : $articleDate;

        $response->setLastModified($date);
        $response->isNotModified($this->getRequest());

        return $response;
    }

The ``Response::isNotModified()`` method compares the ``If-Modified-Since``
header sent by the request with the ``Last-Modified`` header set on the
response. If they are equivalent, the ``Response`` will be set to a 304 status
code.
``Response::isNotModified()``方法把请求发送的``If-Modified-Since``和响应的``Last-Modified``
头文件值作对比。如果它们是相同的，那么响应就会是一个304 status code。

.. note::

    The ``If-Modified-Since`` request header equals the ``Last-Modified``
    header of the last response sent to the client for the particular resource.
    This is how the client and server communicate with each other and decide
    whether or not the resource has been updated since it was cached.
    ``If-Modified-Since``请求头文件和最后一个发送给客户端的响应的``Last-Modified``头文件相等。
    这就是客户端如何与服务器通信并确定源文件在被缓存之后有没有被更新。

.. index::
   single: Cache; Conditional Get
   single: HTTP; 304

.. _optimizing-cache-validation:

Optimizing your Code with Validation
优化你的验证代码
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The main goal of any caching strategy is to lighten the load on the application.
Put another way, the less you do in your application to return a 304 response,
the better. The ``Response::isNotModified()`` method does exactly that by
exposing a simple and efficient pattern::
缓存机制的主要目的就是要减轻应用的负载。换句话说，要使你的应用返回一个304响应，你的应用做的
工作越少越好。``Response::isNotModified()``方法使用一种简单有效的模式来达到这个目的：

    public function showAction($articleSlug)
    {
        // Get the minimum information to compute
        // the ETag or the Last-Modified value
        // (based on the Request, data is retrieved from
        // a database or a key-value store for instance)
        $article = // ...

        // create a Response with a ETag and/or a Last-Modified header
        $response = new Response();
        $response->setETag($article->computeETag());
        $response->setLastModified($article->getPublishedAt());

        // Check that the Response is not modified for the given Request
        if ($response->isNotModified($this->getRequest())) {
            // return the 304 Response immediately
            return $response;
        } else {
            // do more work here - like retrieving more data
            $comments = // ...

            // or render a template with the $response you've already started
            return $this->render(
                'MyBundle:MyController:article.html.twig',
                array('article' => $article, 'comments' => $comments),
                $response
            );
        }
    }

When the ``Response`` is not modified, the ``isNotModified()`` automatically sets
the response status code to ``304``, removes the content, and removes some
headers that must not be present for ``304`` responses (see
:method:`Symfony\\Component\\HttpFoundation\\Response::setNotModified`).
当响应没有被修改，``isNotModified()``自动将响应设为304，并移除内容和一些不能在304响应中
出现的头文件（参见:method:`Symfony\\Component\\HttpFoundation\\Response::setNotModified`）。

.. index::
   single: Cache; Vary
   single: HTTP headers; Vary

Varying the Response
vary响应
~~~~~~~~~~~~~~~~~~~~

So far, we've assumed that each URI has exactly one representation of the
target resource. By default, HTTP caching is done by using the URI of the
resource as the cache key. If two people request the same URI of a cacheable
resource, the second person will receive the cached version.
目前为止，我们假设每个URI只有一个目标源文件的页面。默认情况下，HTTP缓存是通过使用源文件的
URI来作为缓存的键（key）的。如果两个用户都请求一样的可以被缓存的源文件的URI，第二个用户
会接收到被缓存的文件。

Sometimes this isn't enough and different versions of the same URI need to
be cached based on one or more request header values. For instance, if you
compress pages when the client supports it, any given URI has two representations:
one when the client supports compression, and one when it does not. This
determination is done by the value of the ``Accept-Encoding`` request header.
有时候这也是不够的，因为同一个URI可能要以它的请求头文件的值为标准来缓存不同版本。
比如，如果你要压缩一个页面，那这个给定的URI就需要有两个不同页面：一个是为那些支持压缩的
客户端准备的，另一个是给那些不支持压缩的客户端准备的。通过读取``Accept-Encoding``
请求头文件中的值就可以确定需要哪一个页面。

In this case, we need the cache to store both a compressed and uncompressed
version of the response for the particular URI and return them based on the
request's ``Accept-Encoding`` value. This is done by using the ``Vary`` response
header, which is a comma-separated list of different headers whose values
trigger a different representation of the requested resource::
在这个例子中，我们需要为某一个URI同时缓存一个压缩页面和一个非压缩页面，并根据请求头文件中的
``Accept-Encoding``值来决定返回哪一个。要达到这个目的，可以使用响应头文件中的Vary参数，它的值可以
激发不同的页面::

    Vary: Accept-Encoding, User-Agent

.. tip::

    This particular ``Vary`` header would cache different versions of each
    resource based on the URI and the value of the ``Accept-Encoding`` and
    ``User-Agent`` request header.
    这个Vary头文件能够根据URI和``Accept-Encoding``、``User-Agent``请求头文件的值来缓存
    源文件的不同版本。

The ``Response`` object offers a clean interface for managing the ``Vary``
header::
response对象提供了一个干净的接口来处理Vary头文件::

    // set one vary header
    $response->setVary('Accept-Encoding');

    // set multiple vary headers
    $response->setVary(array('Accept-Encoding', 'User-Agent'));

The ``setVary()`` method takes a header name or an array of header names for
which the response varies.
``setVary()``方法使用一个头文件名或一系列头文件名作为参数，来确定不同的响应。

Expiration and Validation
过期和验证
~~~~~~~~~~~~~~~~~~~~~~~~~

You can of course use both validation and expiration within the same ``Response``.
As expiration wins over validation, you can easily benefit from the best of
both worlds. In other words, by using both expiration and validation, you
can instruct the cache to serve the cached content, while checking back
at some interval (the expiration) to verify that the content is still valid.
你当然也可以在一个响应中同时使用过期和验证。过期比验证要优越，你可以两个都用。
换句话说，通过同时使用过期和验证，你可以在发送缓存内容的同时向服务器请求验证内容是否还有效。

.. index::
    pair: Cache; Configuration

More Response Methods
更多的响应方法
~~~~~~~~~~~~~~~~~~~~~

The Response class provides many more methods related to the cache. Here are
the most useful ones::
response类提供了与缓存相关的更多方法。以下是一些常用的::

    // Marks the Response stale
    $response->expire();

    // Force the response to return a proper 304 response with no content
    $response->setNotModified();

Additionally, most cache-related HTTP headers can be set via the single
``setCache()`` method::
另外，大多数与缓存有关的HTTP头文件可以通过``setCache()``方法设置::

    // Set cache settings in one call
    $response->setCache(array(
        'etag'          => $etag,
        'last_modified' => $date,
        'max_age'       => 10,
        's_maxage'      => 10,
        'public'        => true,
        // 'private'    => true,
    ));

.. index::
  single: Cache; ESI
  single: ESI

.. _edge-side-includes:

Using Edge Side Includes
使用Edge Side Includes
------------------------

Gateway caches are a great way to make your website perform better. But they
have one limitation: they can only cache whole pages. If you can't cache
whole pages or if parts of a page has "more" dynamic parts, you are out of
luck. Fortunately, Symfony2 provides a solution for these cases, based on a
technology called `ESI`_, or Edge Side Includes. Akamaï wrote this specification
almost 10 years ago, and it allows specific parts of a page to have a different
caching strategy than the main page.
gateway缓存是一个提高网站性能的很好方法。但是它们有一个局限性：它们只能缓存整个页面。如果你不能缓存
整个页面或者页面的某部分是动态的，它就不行了。但是symfony2提供了一种方法来解决这个问题，这个方法
是建立在`ESI`_（或称 Edge Side Includes）基础上的。

The ESI specification describes tags you can embed in your pages to communicate
with the gateway cache. Only one tag is implemented in Symfony2, ``include``,
as this is the only useful one outside of Akamaï context:
ESI标准描述了你可以在你的页面中嵌入的用来与gateway缓存通信的一系列标签。但symfony2只植入了
一个名叫include的标签，因为它是离开Akamaï环境中唯一可以使用的标签：

.. code-block:: html

    <html>
        <body>
            Some content

            <!-- Embed the content of another page here -->
            <esi:include src="http://..." />

            More content
        </body>
    </html>

.. note::

    Notice from the example that each ESI tag has a fully-qualified URL.
    An ESI tag represents a page fragment that can be fetched via the given
    URL.
    注意每个ESI标签都有一个完整URL。一个ESI标签代表了一个可以被给定的URL获取的
    页面片段。

When a request is handled, the gateway cache fetches the entire page from
its cache or requests it from the backend application. If the response contains
one or more ESI tags, these are processed in the same way. In other words,
the gateway cache either retrieves the included page fragment from its cache
or requests the page fragment from the backend application again. When all
the ESI tags have been resolved, the gateway cache merges each into the main
page and sends the final content to the client.
当处理一个请求时，gateway缓存从它的缓存中获取整个页面或者从后台应用中请求它。如果响应中包含了
一个或多个ESI标签，这些也会同样执行。换句话说，gateway缓存或者会直接从缓存中获取这个页面片段
或者向后台应用重新请求这个片段。当处理完整个页面的所有ESI标签后，gateway缓存会将配个片段
合并入主要页面并将最终内容发送给客户端。

All of this happens transparently at the gateway cache level (i.e. outside
of your application). As you'll see, if you choose to take advantage of ESI
tags, Symfony2 makes the process of including them almost effortless.
这些都发生在gateway缓存层面上（或者说在你的应用外部）。如你所见，如果你想利用ESI标签，
symfony2使得包含它们很容易。

Using ESI in Symfony2
在symfony2中使用ESI
~~~~~~~~~~~~~~~~~~~~~

First, to use ESI, be sure to enable it in your application configuration:
首先，要使用ESI，要保证在你的应用配置中激活它：

.. configuration-block::

    .. code-block:: yaml

        # app/config/config.yml
        framework:
            # ...
            esi: { enabled: true }

    .. code-block:: xml

        <!-- app/config/config.xml -->
        <framework:config ...>
            <!-- ... -->
            <framework:esi enabled="true" />
        </framework:config>

    .. code-block:: php

        // app/config/config.php
        $container->loadFromExtension('framework', array(
            // ...
            'esi'    => array('enabled' => true),
        ));

Now, suppose we have a page that is relatively static, except for a news
ticker at the bottom of the content. With ESI, we can cache the news ticker
independent of the rest of the page.
现在，假设我们有一个相对静态的页面，但在它底部有一个新闻滚动条是动态的。通过ESI，
我们可以把滚动条从这个页面独立出来来进行缓存。

.. code-block:: php

    public function indexAction()
    {
        $response = $this->render('MyBundle:MyController:index.html.twig');
        $response->setSharedMaxAge(600);

        return $response;
    }

In this example, we've given the full-page cache a lifetime of ten minutes.
Next, let's include the news ticker in the template by embedding an action.
This is done via the ``render`` helper (See :ref:`templating-embedding-controller`
for more details).
在这个例子中，我们给了整个页面一个10分钟的缓存。下面，我们将使用嵌入控制器的方法来
在这个模板中包含一个新闻滚动条。这是通过render方法实现的（参见:ref:`templating-embedding-controller`）。

As the embedded content comes from another page (or controller for that
matter), Symfony2 uses the standard ``render`` helper to configure ESI tags:
由于被嵌入的内容是来自另一个页面的(或另一个控制器)，symfony2使用一个render方法来配置ESI标签：

.. configuration-block::

    .. code-block:: jinja

        {% render '...:news' with {}, {'standalone': true} %}

    .. code-block:: php

        <?php echo $view['actions']->render('...:news', array(), array('standalone' => true)) ?>

By setting ``standalone`` to ``true``, you tell Symfony2 that the action
should be rendered as an ESI tag. You might be wondering why you would want to
use a helper instead of just writing the ESI tag yourself. That's because
using a helper makes your application work even if there is no gateway cache
installed. Let's see how it works.
通过将standalone设置为true，你告诉了symfony2这个控制器应该被作为ESI提交。你可能会奇怪
为什么要用render而不是你自己写ESI。这是因为render这个helper可以在没有安装gateway缓存的时候，保证
你的应用能正常工作。让我们看它是如何工作的。

When standalone is ``false`` (the default), Symfony2 merges the included page
content within the main one before sending the response to the client. But
when standalone is ``true``, *and* if Symfony2 detects that it's talking
to a gateway cache that supports ESI, it generates an ESI include tag. But
if there is no gateway cache or if it does not support ESI, Symfony2 will
just merge the included page content within the main one as it would have
done were standalone set to ``false``.
当standalone是false的时候（默认情况下），symfony2将包含的页面内容和主要页面合并，并发送给客户端。
但是当standalone是true的时候，*并且*如果symfony2检测到它正在和一个支持ESI的gateway缓存对话，它会
集成一个ESI包含标签。但是如果没有gateway缓存或者如果它不支持ESI包含标签，symfony2会仅仅把被包含的
页面内容与主要页面合并，这和把standalone设置为false的时候效果一样。

.. note::

    Symfony2 detects if a gateway cache supports ESI via another Akamaï
    specification that is supported out of the box by the Symfony2 reverse
    proxy.
    symfony2是一个通过另一个Akamaï标准来检测一个gateway缓存是否支持ESI的，它能被
    symfony2 reverse proxy很好地支持。

The embedded action can now specify its own caching rules, entirely independent
of the master page.
这个嵌入的控制器能独立于整个主要页面来确定它自己的缓存规则。

.. code-block:: php

    public function newsAction()
    {
      // ...

      $response->setSharedMaxAge(60);
    }

With ESI, the full page cache will be valid for 600 seconds, but the news
component cache will only last for 60 seconds.
当有ESI时，整个页面缓存会存在600秒，但是新闻滚动条缓存仅仅会存在60秒。

A requirement of ESI, however, is that the embedded action be accessible
via a URL so the gateway cache can fetch it independently of the rest of
the page. Of course, an action can't be accessed via a URL unless it has
a route that points to it. Symfony2 takes care of this via a generic route
and controller. For the ESI include tag to work properly, you must define
the ``_internal`` route:
ESI的一个要求就是被嵌入的控制器能通过一个URL访问，这样gateway缓存就能够与其他页面内容相独立地
把它取出来了。当然，你不能通过一个没有设置路径的URL访问控制器。symfony2通过一个通用的
路径来配置它。要使ESI包含标签正常工作，你必须定义``_internal``路径：

.. configuration-block::

    .. code-block:: yaml

        # app/config/routing.yml
        _internal:
            resource: "@FrameworkBundle/Resources/config/routing/internal.xml"
            prefix:   /_internal

    .. code-block:: xml

        <!-- app/config/routing.xml -->
        <?xml version="1.0" encoding="UTF-8" ?>

        <routes xmlns="http://symfony.com/schema/routing"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://symfony.com/schema/routing http://symfony.com/schema/routing/routing-1.0.xsd">

            <import resource="@FrameworkBundle/Resources/config/routing/internal.xml" prefix="/_internal" />
        </routes>

    .. code-block:: php

        // app/config/routing.php
        use Symfony\Component\Routing\RouteCollection;
        use Symfony\Component\Routing\Route;

        $collection->addCollection($loader->import('@FrameworkBundle/Resources/config/routing/internal.xml', '/_internal'));

        return $collection;

.. tip::

    Since this route allows all actions to be accessed via a URL, you might
    want to protect it by using the Symfony2 firewall feature (by allowing
    access to your reverse proxy's IP range). See the :ref:`Securing by IP<book-security-securing-ip>` 
    section of the :doc:`Security Chapter </book/security>` for more information 
    on how to do this.
    由于这个路径允许所有的控制器通过URL访问，你可能需要使用symfony2防火墙功能（允许你的reverse proxy的IP范围访问）。
    参见:doc:`Security Chapter </book/security>`的:ref:`Securing by IP<book-security-securing-ip>`章节。

One great advantage of this caching strategy is that you can make your
application as dynamic as needed and at the same time, hit the application as
little as possible.
这个缓存机制的一个重要优点就是你可以使你的应用在尽量少工作的前提下尽量地动态化。

.. note::

    Once you start using ESI, remember to always use the ``s-maxage``
    directive instead of ``max-age``. As the browser only ever receives the
    aggregated resource, it is not aware of the sub-components, and so it will
    obey the ``max-age`` directive and cache the entire page. And you don't
    want that.
    一旦你开始使用ESI，记住必须使用s-maxage来替代max-age。否则浏览器始终只接收源的集合，而不
    接收其子部分，它会遵循max-age并且缓存整个页面。

The ``render`` helper supports two other useful options:
render方法支持另外两个选项：

* ``alt``: used as the ``alt`` attribute on the ESI tag, which allows you
  to specify an alternative URL to be used if the ``src`` cannot be found;
* ``alt``: 在ESI标签上使用alt属性，这样当一个src不能被找到的时候，你可以被允许指定一个
  替代的URL；
  
* ``ignore_errors``: if set to true, an ``onerror`` attribute will be added
  to the ESI with a value of ``continue`` indicating that, in the event of
  a failure, the gateway cache will simply remove the ESI tag silently.
* ``ignore_errors``: 如果被设置为true，一个值为continue的onerror属性会被添加到ESI中，这表示
  如果有错误，gateway缓存会简单地移除ESI标签。

.. index::
    single: Cache; Invalidation

.. _http-cache-invalidation:

Cache Invalidation
缓存失效
------------------

    "There are only two hard things in Computer Science: cache invalidation
    and naming things." --Phil Karlton

You should never need to invalidate cached data because invalidation is already
taken into account natively in the HTTP cache models. If you use validation,
you never need to invalidate anything by definition; and if you use expiration
and need to invalidate a resource, it means that you set the expires date
too far away in the future.
你永远不必使缓存的数据失效（invalidation），因为在HTTP缓存模型中已经默置了。如果你使用验证（validation），
你不必定义某数据的失效；如果你使用过期模式并且需要使数据失效，它表示你将过期日期设置得太长了。

.. note::

    Since invalidation is a topic specific to each type of reverse proxy,
    if you don't worry about invalidation, you can switch between reverse
    proxies without changing anything in your application code.
    由于失效是每个reverse proxy类型中最为独特的，如果你不担心失效，你可以在reverse proxy
    之间转换而不必改变你的应用代码。

Actually, all reverse proxies provide ways to purge cached data, but you
should avoid them as much as possible. The most standard way is to purge the
cache for a given URL by requesting it with the special ``PURGE`` HTTP method.
事实上，所有reverse proxy都提供清除缓存数据的方法，但是你应当尽量避免它们。最标准的清除
某个给定URL的缓存的方法就是使用PURGE HTTP方法请求它。

Here is how you can configure the Symfony2 reverse proxy to support the
``PURGE`` HTTP method::
要配置symfony2 reverse proxy来支持PURGE HTTP方法，你可以::

    // app/AppCache.php

    use Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache;

    class AppCache extends HttpCache
    {
        protected function invalidate(Request $request)
        {
            if ('PURGE' !== $request->getMethod()) {
                return parent::invalidate($request);
            }

            $response = new Response();
            if (!$this->getStore()->purge($request->getUri())) {
                $response->setStatusCode(404, 'Not purged');
            } else {
                $response->setStatusCode(200, 'Purged');
            }

            return $response;
        }
    }

.. caution::

    You must protect the ``PURGE`` HTTP method somehow to avoid random people
    purging your cached data.
    你必须保护PURGE HTTP方法来避免某些人清除你的缓存数据。

Summary
总结
-------

Symfony2 was designed to follow the proven rules of the road: HTTP. Caching
is no exception. Mastering the Symfony2 cache system means becoming familiar
with the HTTP cache models and using them effectively. This means that, instead
of relying only on Symfony2 documentation and code examples, you have access
to a world of knowledge related to HTTP caching and gateway caches such as
Varnish.
symfony2是根据已经被证实的规则来编写的：HTTP。缓存也是一样。要掌握symfony2缓存系统，就要熟悉和
使用HTTP缓存模型。换句话说，除了symfony2自己的文档，你还应该自己掌握别的缓存规则、原理和技术（如Varnish）。

Learn more from the Cookbook
----------------------------

* :doc:`/cookbook/cache/varnish`

.. _`Things Caches Do`: http://tomayko.com/writings/things-caches-do
.. _`Cache Tutorial`: http://www.mnot.net/cache_docs/
.. _`Varnish`: http://www.varnish-cache.org/
.. _`Squid in reverse proxy mode`: http://wiki.squid-cache.org/SquidFaq/ReverseProxy
.. _`expiration model`: http://tools.ietf.org/html/rfc2616#section-13.2
.. _`validation model`: http://tools.ietf.org/html/rfc2616#section-13.3
.. _`RFC 2616`: http://tools.ietf.org/html/rfc2616
.. _`HTTP Bis`: http://tools.ietf.org/wg/httpbis/
.. _`P4 - Conditional Requests`: http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-12
.. _`P6 - Caching: Browser and intermediary caches`: http://tools.ietf.org/html/draft-ietf-httpbis-p6-cache-12
.. _`ESI`: http://www.w3.org/TR/esi-lang