.. index::
   single: Propel

Databases and Propel
数据库和propel
====================

Let's face it, one of the most common and challenging tasks for any application
involves persisting and reading information to and from a database. Symfony2
does not come integrated with any ORMs but the Propel integration is easy.
To get started, read `Working With Symfony2`_.
任何应用的最常见功能就是对数据库载入或读取数据。symfony2并没有同任何ORM合并，但是进行
propel集成很容易。参见`Working With Symfony2`_。

A Simple Example: A Product
一个简单的例子：product
---------------------------

In this section, you'll configure your database, create a ``Product`` object,
persist it to the database and fetch it back out.
在这一节中，你将配置你的数据库，创建一个product对象，将它载入数据库并取出。

.. sidebar:: Code along with the example

    If you want to follow along with the example in this chapter, create an
    ``AcmeStoreBundle`` via: ``php app/console generate:bundle
    --namespace=Acme/StoreBundle``.
    如果你要按照本章中的例子来学习，应该通过``php app/console generate:bundle
    --namespace=Acme/StoreBundle``创建一个``AcmeStoreBundle``。

Configuring the Database
配置数据库
~~~~~~~~~~~~~~~~~~~~~~~~

Before you can start, you'll need to configure your database connection
information.  By convention, this information is usually configured in an
``app/config/parameters.ini`` file:
在你开始之前，你应该配置你的数据库连接信息。通常这个信息是在``app/config/parameters.ini``
文件中配置的：

.. code-block:: ini

    ;app/config/parameters.ini
    [parameters]
        database_driver   = mysql
        database_host     = localhost
        database_name     = test_project
        database_user     = root
        database_password = password
        database_charset  = UTF8

.. note::

    Defining the configuration via ``parameters.ini`` is just a convention. The
    parameters defined in that file are referenced by the main configuration
    file when setting up Propel:
    通过parameters.ini定义配置只是一个惯例。当设置了propel时，在那个文件中定义的参数就可以通过
    主要配置文件访问了：

    .. code-block:: yaml

        propel:
            dbal:
                driver:     %database_driver%
                user:       %database_user%
                password:   %database_password%
                dsn:        %database_driver%:host=%database_host%;dbname=%database_name%;charset=%database_charset%

Now that Propel knows about your database, Symfony2 can create the database for
you:
现在propel已经知道了你的数据库，symfony2能够创建数据库了：

.. code-block:: bash

    php app/console propel:database:create

.. note::

    In this example, you have one configured connection, named ``default``. If
    you want to configure more than one connection, read the `PropelBundle
    configuration section <working-with-symfony2.html#project_configuration>`_.
    在这个例子中，你有一个配置好的连接名叫default。如果你需要配置更多连接，参阅`PropelBundle
    configuration section <working-with-symfony2.html#project_configuration>`_。

Creating a Model Class
创建一个model类
~~~~~~~~~~~~~~~~~~~~~~

In the Propel world, ActiveRecord classes are known as **models** because classes
generated by Propel contain some business logic.
在propel的世界里，ActiveRecord类被称作model，因为通过propel集成的类包含了一些应用逻辑。

.. note::

    For people who use Symfony2 with Doctrine2, **models** are equivalent to
    **entities**.
    如果你使用doctrine2，model也就是entity。

Suppose you're building an application where products need to be displayed.
First, create a ``schema.xml`` file inside the ``Resources/config`` directory
of your ``AcmeStoreBundle``:
假设你要创建一个展示product的应用。首先，在你的AcmeStoreBundle中的Resources/config目录下创建一个schema.xml文件：

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8"?>
    <database name="default" namespace="Acme\StoreBundle\Model" defaultIdMethod="native">
        <table name="product">
            <column name="id" type="integer" required="true" primaryKey="true" autoIncrement="true" />
            <column name="name" type="varchar" primaryString="true" size="100" />
            <column name="price" type="decimal" />
            <column name="description" type="longvarchar" />
        </table>
    </database>

Building the Model
创建model
~~~~~~~~~~~~~~~~~~

After creating your ``schema.xml``, generate your model from it by running:
在创建schema.xml之后，集成你的model：

.. code-block:: bash

    php app/console propel:model:build

This generates each model class to quickly develop your application in the
``Model/`` directory the ``AcmeStoreBundle`` bundle.
这会在AcmeStoreBundle中的Model/目录下迅速集成每个model类。

Creating the Database Tables/Schema
创建数据库表/schema
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now you have a usable ``Product`` class and all you need to persist it. Of
course, you don't yet have the corresponding ``product`` table in your
database. Fortunately, Propel can automatically create all the database tables
needed for every known model in your application.  To do this, run:
现在你有了一个可用的product类，你需要载入它。当然，你数据库中还没有相应的product表。
propel可以为你应用的所有model自动创建所有的数据库表。

.. code-block:: bash

    php app/console propel:sql:build

    php app/console propel:sql:insert --force

Your database now has a fully-functional ``product`` table with columns that
match the schema you've specified.
现在你的数据库有了一个全功能的product表，它的列与你指定的schema相匹配。

.. tip::

    You can run the last three commands combined by using the following
    command: ``php app/console propel:build --insert-sql``.
    你可以将最后三个命令合成一句命令：``php app/console propel:build --insert-sql``。

Persisting Objects to the Database
将数据载入数据库
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that you have a ``Product`` object and corresponding ``product`` table,
you're ready to persist data to the database.  From inside a controller, this
is pretty easy. Add the following method to the ``DefaultController`` of the
bundle::
现在你有了一个product对象以及一个对应的product表，就可以将数据载入数据库了。将以下方法添加到bundle的
``DefaultController``中::

    // src/Acme/StoreBundle/Controller/DefaultController.php
    use Acme\StoreBundle\Model\Product;
    use Symfony\Component\HttpFoundation\Response;
    // ...

    public function createAction()
    {
        $product = new Product();
        $product->setName('A Foo Bar');
        $product->setPrice(19.99);
        $product->setDescription('Lorem ipsum dolor');

        $product->save();

        return new Response('Created product id '.$product->getId());
    }

In this piece of code, you instantiate and work with the ``$product`` object.
When you call the ``save()`` method on it, you persist it to the database. No
need to use other services, the object knows how to persist itself.
在这段代码中，你使用了$product对象。当你执行save()的时候，就将数据载入到了数据库。

.. note::

    If you're following along with this example, you'll need to create a
    :doc:`route <routing>` that points to this action to see it in action.
    你还要创建一个:doc:`route <routing>`来指向这个控制器。

Fetching Objects from the Database
从数据库中获取对象
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fetching an object back from the database is even easier. For example, suppose
you've configured a route to display a specific ``Product`` based on its ``id``
value::
从数据库中获取对象更容易。比如，假设你已经配置了一个根据id显示特定产品的路径::
    
    use Acme\StoreBundle\Model\ProductQuery;
    
    public function showAction($id)
    {
        $product = ProductQuery::create()
            ->findPk($id);
    
        if (!$product) {
            throw $this->createNotFoundException('No product found for id '.$id);
        }
    
        // do something, like pass the $product object into a template
    }

Updating an Object
更新对象
~~~~~~~~~~~~~~~~~~

Once you've fetched an object from Propel, updating it is easy. Suppose you
have a route that maps a product id to an update action in a controller::
一旦你从propel获取了对象，更新它很容易。假设你有一个根据id映射到控制器的路径::
    
    use Acme\StoreBundle\Model\ProductQuery;
    
    public function updateAction($id)
    {
        $product = ProductQuery::create()
            ->findPk($id);
    
        if (!$product) {
            throw $this->createNotFoundException('No product found for id '.$id);
        }
    
        $product->setName('New product name!');
        $product->save();
    
        return $this->redirect($this->generateUrl('homepage'));
    }

Updating an object involves just three steps:
更新对象关乎三个步骤：

#. 从propel中获取对象;
#. 修改对象;
#. 保存对象。

Deleting an Object
删除一个对象
~~~~~~~~~~~~~~~~~~

Deleting an object is very similar, but requires a call to the ``delete()``
method on the object::
删除一个对象很类似，但需要执行delete()方法::

    $product->delete();

Querying for Objects
请求对象
--------------------
    
Propel provides generated ``Query`` classes to run both basic and complex queries
without any work::
propel提供集成的Query类来执行基本的和复杂的请求::
    
    \Acme\StoreBundle\Model\ProductQuery::create()->findPk($id);
    
    \Acme\StoreBundle\Model\ProductQuery::create()
        ->filterByName('Foo')
        ->findOne();

Imagine that you want to query for products which cost more than 19.99, ordered
from cheapest to most expensive. From inside a controller, do the following::
假设你需要请求价格比19.99高的产品，而且将结果从低到高排序。在控制器中::

    $products = \Acme\StoreBundle\Model\ProductQuery::create()
        ->filterByPrice(array('min' => 19.99))
        ->orderByPrice()
        ->find();

In one line, you get your products in a powerful oriented object way. No need
to waste your time with SQL or whatever, Symfony2 offers fully object oriented
programming and Propel respects the same philosophy by providing an awesome
abstraction layer.
仅仅一行，你就使用了一个面向对象的方法来获取product。不需要把时间浪费在sql上，symfony2通过完整的
面向对象方法，propel也遵循同样的原理，它是提供一个抽象层。

If you want to reuse some queries, you can add your own methods to the
``ProductQuery`` class::
如果你想要使用一些请求，你可以将自己的方法添加到ProductQuery类中::

    // src/Acme/StoreBundle/Model/ProductQuery.php
    
    class ProductQuery extends BaseProductQuery
    {
        public function filterByExpensivePrice()
        {
            return $this
                ->filterByPrice(array('min' => 1000))
        }
    }

But note that Propel generates a lot of methods for you and a simple
``findAllOrderedByName()`` can be written without any effort::

    \Acme\StoreBundle\Model\ProductQuery::create()
        ->orderByName()
        ->find();

Relationships/Associations
--------------------------

Suppose that the products in your application all belong to exactly one
"category". In this case, you'll need a ``Category`` object and a way to relate
a ``Product`` object to a ``Category`` object.

Start by adding the ``category`` definition in your ``schema.xml``:

.. code-block:: xml

    <database name="default" namespace="Acme\StoreBundle\Model" defaultIdMethod="native">
        <table name="product">
            <column name="id" type="integer" required="true" primaryKey="true" autoIncrement="true" />
            <column name="name" type="varchar" primaryString="true" size="100" />
            <column name="price" type="decimal" />
            <column name="description" type="longvarchar" />
    
            <column name="category_id" type="integer" />
            <foreign-key foreignTable="category">
                <reference local="category_id" foreign="id" />
            </foreign-key>
        </table>
    
        <table name="category">
            <column name="id" type="integer" required="true" primaryKey="true" autoIncrement="true" />
            <column name="name" type="varchar" primaryString="true" size="100" />
       </table>
    </database>

Create the classes:

.. code-block:: bash

    php app/console propel:model:build

Assuming you have products in your database, you don't want lose them. Thanks to
migrations, Propel will be able to update your database without losing existing
data.

.. code-block:: bash

    php app/console propel:migration:generate-diff

    php app/console propel:migration:migrate

Your database has been updated, you can continue to write your application.

Saving Related Objects
~~~~~~~~~~~~~~~~~~~~~~

Now, let's see the code in action. Imagine you're inside a controller::

    // ...
    use Acme\StoreBundle\Model\Category;
    use Acme\StoreBundle\Model\Product;
    use Symfony\Component\HttpFoundation\Response;
    // ...
    
    class DefaultController extends Controller
    {
        public function createProductAction()
        {
            $category = new Category();
            $category->setName('Main Products');
    
            $product = new Product();
            $product->setName('Foo');
            $product->setPrice(19.99);
            // relate this product to the category
            $product->setCategory($category);
    
            // save the whole
            $product->save();
    
            return new Response(
                'Created product id: '.$product->getId().' and category id: '.$category->getId()
            );
        }
    }

Now, a single row is added to both the ``category`` and product tables. The
``product.category_id`` column for the new product is set to whatever the id is
of the new category. Propel manages the persistence of this relationship for
you.

Fetching Related Objects
~~~~~~~~~~~~~~~~~~~~~~~~

When you need to fetch associated objects, your workflow looks just like it did
before.  First, fetch a ``$product`` object and then access its related
``Category``::

    // ...
    use Acme\StoreBundle\Model\ProductQuery;
    
    public function showAction($id)
    {
        $product = ProductQuery::create()
            ->joinWithCategory()
            ->findPk($id);
    
        $categoryName = $product->getCategory()->getName();
    
        // ...
    }

Note, in the above example, only one query was made.

More information on Associations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You will find more information on relations by reading the dedicated chapter on
`Relationships`_.

Lifecycle Callbacks
-------------------

Sometimes, you need to perform an action right before or after an object is
inserted, updated, or deleted.  These types of actions are known as "lifecycle"
callbacks or "hooks", as they're callback methods that you need to execute
during different stages of the lifecycle of an object (e.g. the object is
inserted, updated, deleted, etc).

To add a hook, just add a new method to the object class::

    // src/Acme/StoreBundle/Model/Product.php
    
    // ...
    
    class Product extends BaseProduct
    {
        public function preInsert(\PropelPDO $con = null)
        {
            // do something before the object is inserted
        }
    }

Propel provides the following hooks:

* ``preInsert()`` code executed before insertion of a new object
* ``postInsert()`` code executed after insertion of a new object
* ``preUpdate()`` code executed before update of an existing object
* ``postUpdate()`` code executed after update of an existing object
* ``preSave()`` code executed before saving an object (new or existing)
* ``postSave()`` code executed after saving an object (new or existing)
* ``preDelete()`` code executed before deleting an object
* ``postDelete()`` code executed after deleting an object


Behaviors
---------

All bundled behaviors in Propel are working with Symfony2. To get more
information about how to use Propel behaviors, look at the `Behaviors reference
section`_.

Commands
--------

You should read the dedicated section for `Propel commands in Symfony2`_.

.. _`Working With Symfony2`: http://www.propelorm.org/cookbook/symfony2/working-with-symfony2.html#installation
.. _`Relationships`: http://www.propelorm.org/documentation/04-relationships.html
.. _`Behaviors reference section`: http://www.propelorm.org/documentation/#behaviors_reference
.. _`Propel commands in Symfony2`: http://www.propelorm.org/cookbook/symfony2/working-with-symfony2#commands
